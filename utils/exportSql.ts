import type { ERSchema, ERTable, ERColumn } from '@/lib/types';

/**
 * Convert ERD schema to SQL CREATE TABLE statements
 */
export function exportToSQL(schema: ERSchema, projectName: string = 'database'): void {
    const sql = generateSQL(schema);
    downloadSQL(sql, projectName);
}

/**
 * Topologically sort tables so parent tables come before child (FK) tables.
 * Falls back to original order if a cycle is detected.
 */
function sortTablesByDependency(tables: ERTable[]): ERTable[] {
    const nameMap = new Map(tables.map(t => [t.name, t]));
    const visited = new Set<string>();
    const result: ERTable[] = [];

    function visit(name: string, chain: Set<string>) {
        if (visited.has(name)) return;
        if (chain.has(name)) return; // cycle — skip
        chain.add(name);
        const table = nameMap.get(name);
        if (table) {
            // Visit all parent tables first
            for (const col of table.columns) {
                if (col.isForeignKey && col.references?.table) {
                    visit(col.references.table, chain);
                }
            }
            if (!visited.has(name)) {
                visited.add(name);
                result.push(table);
            }
        }
        chain.delete(name);
    }

    for (const table of tables) {
        visit(table.name, new Set());
    }

    return result;
}

/**
 * Generate SQL CREATE TABLE statements from schema
 */
export function generateSQL(schema: ERSchema): string {
    const sqlStatements: string[] = [];

    // Header
    sqlStatements.push('-- Generated by ERDify Studio');
    sqlStatements.push(`-- Date: ${new Date().toISOString()}`);
    sqlStatements.push('-- https://www.erdify.my.id\n');

    // MySQL settings for proper import (XAMPP / phpMyAdmin compatible)
    sqlStatements.push('SET FOREIGN_KEY_CHECKS=0;');
    sqlStatements.push('SET SQL_MODE="";'); // clear strict mode to allow nullable timestamps
    sqlStatements.push('SET time_zone = "+00:00";\n');

    // Build a map: tableName -> columnName -> sqlType
    // of ALL columns in the schema so we can look up what type
    // a FK-target column actually is, and normalise types to match.
    const colTypeMap = new Map<string, Map<string, string>>();
    schema.tables.forEach(table => {
        const colMap = new Map<string, string>();
        table.columns.forEach(col => {
            colMap.set(col.name, resolveColumnSqlType(col));
        });
        colTypeMap.set(table.name, colMap);
    });

    // Build a set of "tableName.colName" that are referenced as FK targets
    // so that generateCreateTable knows to add an explicit KEY for them.
    const fkTargetSet = new Set<string>();
    schema.tables.forEach(table => {
        table.columns.forEach(col => {
            if (col.isForeignKey && col.references) {
                fkTargetSet.add(`${col.references.table}.${col.references.column}`);
            }
        });
    });

    // Sort so parent tables are defined before child tables
    const sorted = sortTablesByDependency(schema.tables);

    sorted.forEach((table) => {
        sqlStatements.push(generateCreateTable(table, schema, colTypeMap, fkTargetSet));
    });

    sqlStatements.push('SET FOREIGN_KEY_CHECKS=1;');

    return sqlStatements.join('\n');
}

/**
 * Resolve the final SQL type for a column (handles TIMESTAMP special case)
 */
function resolveColumnSqlType(column: ERColumn): string {
    const rawType = column.type.toUpperCase().trim();
    const isTimestamp = rawType === 'TIMESTAMP' || rawType.startsWith('TIMESTAMP');
    const isNullable = !column.isNotNull && !column.isPrimaryKey;
    if (isTimestamp && isNullable) return 'DATETIME';
    if (isTimestamp && !isNullable) return 'DATETIME';
    return mapDataType(column.type);
}


/**
 * Generate CREATE TABLE statement for a single table.
 * colTypeMap: pre-resolved SQL types for every column in every table.
 * fkTargetSet: "tableName.colName" pairs that are referenced by FK in other tables.
 */
function generateCreateTable(
    table: ERTable,
    schema: ERSchema,
    colTypeMap: Map<string, Map<string, string>>,
    fkTargetSet: Set<string>
): string {
    const lines: string[] = [];

    lines.push(`CREATE TABLE IF NOT EXISTS \`${table.name}\` (`);

    // Column definitions
    const allDefs: string[] = [];

    table.columns.forEach((col) => {
        // For FK columns: override type to match the referenced column's type.
        // This is THE most common cause of errno 150 type-mismatch errors.
        if (col.isForeignKey && col.references) {
            const refType = colTypeMap.get(col.references.table)?.get(col.references.column);
            if (refType) {
                // Strip AUTO_INCREMENT from the referenced type (FKs can't be AUTO_INCREMENT)
                const fkType = refType.replace(/\s*AUTO_INCREMENT/i, '').trim();
                allDefs.push(`  ${generateColumnDefinitionWithType(col, fkType)}`);
                return;
            }
        }
        allDefs.push(`  ${generateColumnDefinition(col)}`);
    });

    // PRIMARY KEY constraint
    const primaryKeys = table.columns.filter(col => col.isPrimaryKey);
    if (primaryKeys.length > 0) {
        const pkColumns = primaryKeys.map(col => `\`${col.name}\``).join(', ');
        allDefs.push(`  PRIMARY KEY (${pkColumns})`);
    }

    // For columns that are FK targets in OTHER tables but NOT marked as PK here,
    // add an explicit KEY so MySQL can find the required index.
    table.columns.forEach(col => {
        const isAlreadyPk = col.isPrimaryKey;
        const isTarget = fkTargetSet.has(`${table.name}.${col.name}`);
        if (isTarget && !isAlreadyPk) {
            allDefs.push(`  KEY \`key_${table.name}_${col.name}\` (\`${col.name}\`)`);
        }
    });

    // INDEX for FK columns on this table (child side — required by MySQL)
    const foreignKeys = table.columns.filter(col => col.isForeignKey && col.references);
    foreignKeys.forEach((col) => {
        if (col.references) {
            allDefs.push(`  INDEX \`idx_${table.name}_${col.name}\` (\`${col.name}\`)`);
        }
    });

    // FOREIGN KEY constraints
    foreignKeys.forEach((col) => {
        if (col.references) {
            allDefs.push(
                `  CONSTRAINT \`fk_${table.name}_${col.name}\` FOREIGN KEY (\`${col.name}\`) REFERENCES \`${col.references.table}\` (\`${col.references.column}\`) ON DELETE CASCADE ON UPDATE CASCADE`
            );
        }
    });

    lines.push(allDefs.join(',\n'));
    lines.push(`) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n`);

    return lines.join('\n');
}

/**
 * Generate column definition using a pre-resolved SQL type string (used for FK columns
 * so their type is forced to match the referenced column).
 */
function generateColumnDefinitionWithType(column: ERColumn, sqlType: string): string {
    const parts: string[] = [];
    parts.push(`\`${column.name}\` ${sqlType}`);

    if (column.isNotNull || column.isPrimaryKey) {
        parts.push('NOT NULL');
    }
    if (column.isUnique && !column.isPrimaryKey) {
        parts.push('UNIQUE');
    }
    return parts.join(' ');
}


/**
 * Generate column definition with type and constraints
 */
function generateColumnDefinition(column: ERColumn): string {
    const parts: string[] = [];

    // Resolve the final SQL type first so we can make decisions based on it
    const rawType = column.type.toUpperCase().trim();
    const isTimestamp = rawType === 'TIMESTAMP' || rawType.startsWith('TIMESTAMP');
    const isNullable = !column.isNotNull && !column.isPrimaryKey;

    // For nullable TIMESTAMP columns, use DATETIME to avoid MySQL strict mode errors
    // TIMESTAMP has implicit NOT NULL and DEFAULT CURRENT_TIMESTAMP semantics that
    // differ per MySQL version (especially XAMPP). DATETIME is simpler and portable.
    let sqlType: string;
    if (isTimestamp && isNullable) {
        sqlType = 'DATETIME DEFAULT NULL';
    } else if (isTimestamp && !isNullable) {
        sqlType = 'DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP';
    } else {
        sqlType = mapDataType(column.type);
    }

    parts.push(`\`${column.name}\` ${sqlType}`);

    // NOT NULL (skip if we baked it into the type string above)
    if (!isTimestamp && (column.isNotNull || column.isPrimaryKey)) {
        parts.push('NOT NULL');
    }

    // AUTO_INCREMENT for integer PKs
    if (column.isPrimaryKey) {
        const baseType = rawType.split('(')[0];
        const intTypes = ['INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'TINYINT', 'MEDIUMINT'];
        if (intTypes.includes(baseType)) {
            parts.push('AUTO_INCREMENT');
        }
    }

    if (column.isUnique && !column.isPrimaryKey) {
        parts.push('UNIQUE');
    }

    // DEFAULT value — skip if we already embedded it in the type string (timestamp case)
    if (!isTimestamp && column.defaultValue !== undefined && column.defaultValue !== '' && !column.isPrimaryKey) {
        parts.push(`DEFAULT ${formatDefaultValue(column.defaultValue, column.type)}`);
    }

    return parts.join(' ');
}

/**
 * Map ERD data types to MySQL-compatible SQL types
 */
function mapDataType(type: string): string {
    const typeUpper = type.toUpperCase().trim();

    // Already has parameters like VARCHAR(255) or DECIMAL(12,2) — pass through
    if (typeUpper.includes('(')) {
        return type.trim();
    }

    const typeMap: Record<string, string> = {
        // Integers
        'INT': 'INT',
        'INTEGER': 'INT',
        'BIGINT': 'BIGINT',
        'SMALLINT': 'SMALLINT',
        'TINYINT': 'TINYINT',
        'MEDIUMINT': 'MEDIUMINT',
        'NUMBER': 'INT',

        // Decimals
        'DECIMAL': 'DECIMAL(12,2)',
        'NUMERIC': 'DECIMAL(12,2)',
        'FLOAT': 'FLOAT',
        'DOUBLE': 'DOUBLE',
        'REAL': 'DOUBLE',

        // Strings
        'STRING': 'VARCHAR(255)',
        'VARCHAR': 'VARCHAR(255)',
        'CHAR': 'CHAR(1)',
        'TEXT': 'TEXT',
        'LONGTEXT': 'LONGTEXT',
        'MEDIUMTEXT': 'MEDIUMTEXT',
        'TINYTEXT': 'TINYTEXT',

        // Date/Time — use DATETIME instead of TIMESTAMP for portability
        // TIMESTAMP is handled separately in generateColumnDefinition
        'DATE': 'DATE',
        'TIME': 'TIME',
        'DATETIME': 'DATETIME',
        'TIMESTAMP': 'DATETIME', // safe fallback if called directly
        'YEAR': 'YEAR',

        // Boolean
        'BOOLEAN': 'TINYINT(1)',
        'BOOL': 'TINYINT(1)',

        // Binary / Other
        'BLOB': 'BLOB',
        'JSON': 'JSON',
        'UUID': 'CHAR(36)',
    };

    return typeMap[typeUpper] || `VARCHAR(255)`;
}

/**
 * Format default value based on data type
 */
function formatDefaultValue(value: string, type: string): string {
    const typeUpper = type.toUpperCase();

    if (value.toUpperCase() === 'NULL') return 'NULL';
    if (value.toUpperCase() === 'CURRENT_TIMESTAMP') return 'CURRENT_TIMESTAMP';

    if (typeUpper.includes('INT') || typeUpper.includes('DECIMAL') ||
        typeUpper.includes('NUMERIC') || typeUpper.includes('FLOAT') ||
        typeUpper.includes('DOUBLE')) {
        return value;
    }

    if (typeUpper === 'BOOLEAN' || typeUpper === 'BOOL') {
        return value.toLowerCase() === 'true' || value === '1' ? '1' : '0';
    }

    return `'${value.replace(/'/g, "''")}'`;
}

/**
 * Download SQL as a file
 */
function downloadSQL(sql: string, projectName: string): void {
    const blob = new Blob([sql], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');

    link.href = url;
    link.download = `${projectName.replace(/\s+/g, '_')}_schema.sql`;
    document.body.appendChild(link);
    link.click();

    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}
