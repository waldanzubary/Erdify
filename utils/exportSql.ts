import type { ERSchema, ERTable, ERColumn } from '@/lib/types';

/**
 * Convert ERD schema to SQL CREATE TABLE statements
 */
export function exportToSQL(schema: ERSchema, projectName: string = 'database'): void {
    const sql = generateSQL(schema);
    downloadSQL(sql, projectName);
}

/**
 * Generate SQL CREATE TABLE statements from schema
 */
export function generateSQL(schema: ERSchema): string {
    const sqlStatements: string[] = [];

    // Add header comment
    sqlStatements.push('-- Generated by ERDify Studio');
    sqlStatements.push(`-- Date: ${new Date().toISOString()}`);
    sqlStatements.push('-- https://www.erdify.my.id\n');

    // Generate CREATE TABLE for each table
    schema.tables.forEach((table) => {
        sqlStatements.push(generateCreateTable(table, schema));
    });

    return sqlStatements.join('\n');
}

/**
 * Generate CREATE TABLE statement for a single table
 */
function generateCreateTable(table: ERTable, schema: ERSchema): string {
    const lines: string[] = [];

    lines.push(`CREATE TABLE ${table.name} (`);

    // Add column definitions
    const columnDefs = table.columns.map((col, idx) => {
        const isLast = idx === table.columns.length - 1;
        const comma = isLast ? '' : ',';
        return `    ${generateColumnDefinition(col)}${comma}`;
    });
    lines.push(...columnDefs);

    // Add PRIMARY KEY constraint if exists
    const primaryKeys = table.columns.filter(col => col.isPrimaryKey);
    if (primaryKeys.length > 0) {
        const pkColumns = primaryKeys.map(col => col.name).join(', ');
        lines.push(`,\n    PRIMARY KEY (${pkColumns})`);
    }

    // Add FOREIGN KEY constraints
    const foreignKeys = table.columns.filter(col => col.isForeignKey && col.references);
    foreignKeys.forEach((col) => {
        if (col.references) {
            lines.push(
                `,\n    FOREIGN KEY (${col.name}) REFERENCES ${col.references.table}(${col.references.column})`
            );
        }
    });

    lines.push(');\n');

    return lines.join('\n');
}

/**
 * Generate column definition with type and constraints
 */
function generateColumnDefinition(column: ERColumn): string {
    const parts: string[] = [];

    // Column name and type
    parts.push(`${column.name} ${mapDataType(column.type)}`);

    // Constraints
    if (column.isNotNull && !column.isPrimaryKey) {
        parts.push('NOT NULL');
    }

    if (column.isUnique && !column.isPrimaryKey) {
        parts.push('UNIQUE');
    }

    if (column.defaultValue !== undefined && column.defaultValue !== '') {
        parts.push(`DEFAULT ${formatDefaultValue(column.defaultValue, column.type)}`);
    }

    return parts.join(' ');
}

/**
 * Map ERD data types to SQL types
 */
function mapDataType(type: string): string {
    const typeUpper = type.toUpperCase();

    // Already valid SQL types - return as-is
    const validTypes = [
        'INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'TINYINT',
        'DECIMAL', 'NUMERIC', 'FLOAT', 'DOUBLE', 'REAL',
        'CHAR', 'VARCHAR', 'TEXT', 'LONGTEXT', 'MEDIUMTEXT',
        'DATE', 'TIME', 'DATETIME', 'TIMESTAMP',
        'BOOLEAN', 'BOOL', 'BLOB', 'JSON'
    ];

    // Check for types with parameters (e.g., VARCHAR(255))
    if (typeUpper.includes('(')) {
        return type;
    }

    // Check if it's a valid type without parameters
    const baseType = typeUpper.split('(')[0].trim();
    if (validTypes.includes(baseType)) {
        return type;
    }

    // Map common variations
    const typeMap: Record<string, string> = {
        'STRING': 'VARCHAR(255)',
        'NUMBER': 'INT',
        'FLOAT': 'DECIMAL(10,2)',
        'BOOL': 'BOOLEAN',
        'DATETIME': 'DATETIME',
        'TIMESTAMP': 'TIMESTAMP',
    };

    return typeMap[typeUpper] || 'VARCHAR(255)';
}

/**
 * Format default value based on data type
 */
function formatDefaultValue(value: string, type: string): string {
    const typeUpper = type.toUpperCase();

    // Numeric types don't need quotes
    if (typeUpper.includes('INT') || typeUpper.includes('DECIMAL') ||
        typeUpper.includes('NUMERIC') || typeUpper.includes('FLOAT')) {
        return value;
    }

    // Boolean values
    if (typeUpper === 'BOOLEAN' || typeUpper === 'BOOL') {
        return value.toLowerCase() === 'true' ? 'TRUE' : 'FALSE';
    }

    // NULL value
    if (value.toUpperCase() === 'NULL') {
        return 'NULL';
    }

    // String values need quotes
    return `'${value.replace(/'/g, "''")}'`; // Escape single quotes
}

/**
 * Download SQL as a file
 */
function downloadSQL(sql: string, projectName: string): void {
    const blob = new Blob([sql], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');

    link.href = url;
    link.download = `${projectName.replace(/\s+/g, '_')}_schema.sql`;
    document.body.appendChild(link);
    link.click();

    // Cleanup
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}
